/* autogenerated by Processing revision 1282 on 2022-04-19 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class SnakeGame extends PApplet {

/*SNAKE GAME*/

// add the frame rate selection thing 
// addd high score and score display for the game over screen
// add the random apple generation after a certain amount of time (make it ike 50% chance)
// Reset score once dead      
// Display the state of the settings for each (put like ON over the green square and OFF over the red one)
// add eating apple animations 

// Rows and columns for each block and its size
int rows; int columns; 
int sizeB = 10; // Block Size 
int appleAmt = 1; 
int gamestate = 0; // 0 is title screen, 1 game over, 2 is game, 3 is settings page to adjust everything 
int startLength = 10; 
int textS = 100; 
int score; int highscore = 0;  
int snakeDelay = 40; // controls how frequent snake is moved 
int titleX = 80; int titleY = 80; // the title positions for the game
int theme; 

// Data saving stuff //

/*
first line is highscore from previous games
second line is setting state one 
third line is setting state two
fourth line is the theme index 
 */

PrintWriter data; 

/* Colors for the game */ 
int settingsColor = 0xFFA9A9A9; 
int grey = 0xFFC0C0C0;

// 1 is normal, 2 is black and white, 3 is high contrast 
int[] BACKGROUND = new int[]{0xFF03092B, 0xFFFFFFFF, 0xFF333333}; 
int[] SNAKE = new int[]{0xFF69FF5E, 0xFF000000, 0xFF00BFFF}; 
int[] APPLE = new int[]{0xFFEB4034, 0xFF380000, 0xFF8CFF00}; 
int[] SCORE = new int[]{0xFF2DFF00, 0xFF000000, 0xFF00BFFF}; 
int[] SETTINGTRUE = new int[]{ 0xFF5AFF00,0xFFD1FFB8,0xFF69FF5E}; 
int[] SETTINGFALSE = new int[]{0xFFFF0000,0xFFFF9E9E,0xFFFF0550}; 

/* Game settings */ 
boolean selfCollide = true; 
boolean teleportBorders = true; 

/* Refresh timers */ 
int last = 0; 
int m = 0; 
int lastGamestate = 0; 

/* Game font stuff */ 
PFont gameFont;

 public void saveData(){
  data = createWriter("data.txt");
  data.println(highscore);
  data.println(selfCollide);
  data.println(teleportBorders); 
  data.println(theme); 
  data.flush(); 
  data.close(); 
}

 public void loadData(){
  String[] loadedFile = loadStrings("data.txt");
  highscore = parseInt(loadedFile[0]); 
  selfCollide = parseBoolean(loadedFile[1]); 
  teleportBorders = parseBoolean(loadedFile[2]); 
  theme = parseInt(loadedFile[3]); 
}

/* Prints the score on the bottom right */ 
 public void showScore(){
  textFont(gameFont);
  fill(BACKGROUND[theme]); 
  rect(0, height-50, width, 50); // clear the thing before drawing a new one over it. 
  fill(SCORE[theme]); 
  textSize(30);
  text(score, 0, height-10);
}

/* Position Class */
class pos{
  int x; int y; 
  pos(int x, int y){
    this.x = x; 
    this.y = y; 
  }
}

/* Apple class for snakes */ 
class Apple{
  int posX, posY; 
  Apple(int x, int y){
    posX = x; 
    posY = y; 
  }

   public void drawApple(){
    fill(APPLE[theme]); 
    rect(posX*sizeB, posY*sizeB, sizeB, sizeB);     
  }

}

// Snake class for the player // 
class Snake{
  int len, dir = 3, x, y;  // The length of the snake 
  ArrayList<pos> positions = new ArrayList<pos>(); // Tracks where the snake is  

  Snake(int length, int posx, int posy){
    len = length; 
    x = posx;
    y = posy; 
    for (int i = 0; i < length; i++){ 
      positions.add(new pos(1,1)); 
      positions.set(i, new pos(x, y--));
    } 
  } 

   public void printPositions(){
    println("SNAKE POSITIONS"); 
    for(int i = 0; i < positions.size(); i++){
      println(" X:", positions.get(i).x, " Y:", positions.get(i).y); 
    }
    println(""); 
  }

   public void reset(){
    positions.clear();
    x = 20; y = 20;  
    for (int i = 0; i < startLength; i++){ 
      positions.add(new pos(0,0)); 
      positions.set(i, new pos(x, y--));
    } 
    dir = 3; 
  }

   public void drawSnake(){
    for(int i = 0; i < positions.size(); i++){
      fill(SNAKE[theme]); 
      rect(positions.get(i).x * sizeB, positions.get(i).y * sizeB, sizeB, sizeB); 
    }
  }

   public void changeDir(int direction){
    dir = direction; 
  }

   public void move(int direction){
    dir = direction; 
    if (dir == 1){
      // Move up
      y -= 1; 
    } else if (dir == 2){
      // Move left
      x -= 1; 
    } else if (dir == 3){
      // Move down
      y+=1;  
    } else if (dir == 4){
      // Move right 
      x+=1; 
    }
    // Add a new coordinate into the thing then remove the last one // 
    pos remove = positions.get(positions.size()-1); 
    fill(BACKGROUND[theme]); 
    rect(remove.x*sizeB, remove.y*sizeB, sizeB, sizeB); 
    positions.add(0, new pos(x, y)); 

    while (positions.size() > len){
      positions.remove(positions.size()-1); 
    }

  }

   public void lengthen(int i){
    len+=i; 
  }

   public void checkCollision(){
    if (selfCollide){
      for (int i = 0; i < positions.size(); i++){
        if (i != 0){
          if (positions.get(i).x == x && positions.get(i).y == y){
            println("SNAKE COLLIDED WITH ITSELF ", x, " ", y); 
            gamestate = 1; 
          }
        }
      }
    }
    if (teleportBorders){
      if (x < 0){
        x = columns; 
      }
      if (y < 0){
        y = rows; 
      }
      if (x > columns){
        x = -1; 
      }
      if (y > rows){
        y = -1; 
      } 
    } else {
      if (x < 0){
        gamestate = 1;  
      }
      if (y < 0){
        gamestate = 1;  
      }
      if (x > columns){
        gamestate = 1; 
      }
      if (y > rows){
        gamestate = 1; 
      } 
    }
  }

}

class Button{
  int x, y;
  String msg;
  boolean state = false;   
  
  Button(String msg, int x, int y){
    this.msg = msg; this.x = x; this.y = y; 
  }
  
   public void show(){
    textSize(30);
    if (state){
      fill(SETTINGTRUE[theme]); 
    } else {
      fill(SETTINGFALSE[theme]); 
    } 
    rect(x, y, 40, 40); 
    fill(grey); 
    text(msg, x + 60, y+30);
  }

   public void changeState(){
    if (mouseX > x && mouseX < x+40 && mouseY > y && mouseY < y+40){
      if (state == false){
        state = true; 
      } else {
        state = false; 
      }
    }
    this.show(); 
  }

   public void setState(boolean newState){
    state = newState; 
  }

   public boolean getState(){
    return state; 
  }

}

class triButton{
  int a, b, c, x, y; String msg; int val; 

  triButton(int x, int y, int a, int b, int c, String msg){
    this.a = a;
    this.b = b;
    this.c = c;
    this.msg = msg;
    this.x = x; 
    this.y = y; 
    val = a; 
  } 

  // displays the triple button arrangement 
   public void show(){
    if (a == val){
      
    }
    if (b == val){

    }
    if (c == val){

    }
  }

   public void changeState(){

  }

  // retuns the value of the active button
   public void getValue(){

  }


}

Snake player = new Snake(startLength, 20, 20);  
ArrayList<Apple> apples = new ArrayList<Apple>();
Button selfCollisionToggle = new Button("Self Collision", 50, 200); 
Button teleportBordersToggle = new Button("Teleport Borders", 50, 270); 

 public void generateApple(){
  for(int i = 0; i < appleAmt; i++){
    apples.add(new Apple(parseInt(random(0, rows-1)), parseInt(random(0, rows-1)))); 
  }
}

 public void checkApple(){
  for(int i = 0; i < apples.size(); i++){
    if (apples.get(i).posX == player.x && apples.get(i).posY == player.y){
      println("GOT APPLE!!!");
      player.lengthen(5); 
      apples.remove(i); 
      apples.add(new Apple(parseInt(random(0, rows-1)), parseInt(random(0, rows-1)))); 
      score+=1; 
      showScore(); 
    }
  }
}

 public void drawApples(){
  for (int i = 0; i < apples.size(); i++){
    apples.get(i).drawApple(); 
  }
}


 public void setup() {
  // setting up the window size and name 
  /* size commented out by preprocessor */;
  surface.setTitle("Snake Game");

  loadData(); 

  // Rows and columns in the game 
  println("ROWS:", height/sizeB);
  println("COLUMNS:", width/sizeB); 
  rows = height/sizeB; 
  columns = width/sizeB; 
  
  // setting up button defaults 
  selfCollisionToggle.setState(selfCollide); 
  teleportBordersToggle.setState(teleportBorders); 

  // Display the title screen 
  if (gamestate == 0){
    gameFont = createFont("SourceCodePro-Black.ttf", 1);
    fill(SNAKE[theme]); 
    textFont(gameFont); 
    textSize(textS);
    background(BACKGROUND[theme]); 
    text("Snake Game", titleX ,titleY); 
  }
}

 public void draw() {  
  // Title screen for the game 
  if (gamestate == 0){
    // Title screen moment 
    if (lastGamestate != 0){
      fill(SNAKE[theme]); 
      background(BACKGROUND[theme]); 
      textSize(textS);
      text("Snake Game", titleX , titleY); 
      println("\tGAME SETTINGS");
      println("SELF COLLIDE:", selfCollide);
      println("TELEPORT WALLS:", teleportBorders);  
    }
  }

  // Game over screen 
  if (gamestate == 1){
    // Game over screen // 
      background(BACKGROUND[theme]); 
      fill(APPLE[theme]);
      textSize(textS);
      text("Game Over", titleX, titleY); 
      player.len = startLength; 
      player.dir = 3; // make it move down
      if (score > highscore) {
        highscore = score; 
      }
      saveData(); 
  }

  // Game loop itself 
  if (gamestate == 2){
    // Actual game loop // 
    if (lastGamestate != 2){ // first game loop happens here 
      for(int i = 0; i < apples.size(); i++){apples.remove(i);} 
      noStroke();  
      player.reset(); 
      background(BACKGROUND[theme]);
      generateApple();
      score = 0; 
    }
    // Timer stuff // 
    m = millis()-last; 

    // every 50 milliseconds you move the snake a little // 
    if (millis() > last+snakeDelay){
      last = millis();  
      player.move(player.dir); 
      checkApple();
      player.checkCollision(); 
    }
    // Draw the apple and the snake // 
    drawApples();
    player.drawSnake(); 
  }

  // Settings page
  if (gamestate == 3){
    if (lastGamestate != 3){
      noStroke();  
      background(settingsColor);
      textSize(70); 
      fill(SCORE[theme]); 
      text("SETTINGS", titleX, titleY); 
      
      // Button stuff
      selfCollisionToggle.show();
      teleportBordersToggle.show(); 
    }
    saveData(); 
  }

  // Set the last gamestate variable to the gamestate after being used 
  lastGamestate = gamestate; 
}

 public void keyPressed() {

  if (gamestate == 0){
    if (keyPressed){
      gamestate = 2; 
    }
  }

  if (gamestate == 1){
    if (keyPressed){
      gamestate = 0;
    }
  }

  if (keyPressed && gamestate == 2) {

    // For each directional key change the direction and move it based on that direction // 
    if (key == 'w') {
      if (player.dir != 3){
        player.changeDir(1); 
      }
    } else if (key == 'a') {
      if (player.dir != 4){
        player.changeDir(2); 
      }  
    } else if (key == 'd') {
      if (player.dir != 2){
        player.changeDir(4); 
      } 
    } else if (key == 's') {
      if (player.dir != 1){
        player.changeDir(3); 
      }
    }

    // is the user wants to quit bring them to game over screen 
    if (key == 'q'){
      for(int i = 0; i < apples.size(); i++){
        apples.remove(0); 
      }
      player.len = startLength; 
      gamestate = 1; // q is for quit so when q is pressed leave the game thing. 

    }

    if (key == 'E' || key == 'e'){
      gamestate = 3;
    }

  }

  if (gamestate == 3){
    if (key == 'q'){
      gamestate = 0;
    }
  }

}  

 public void mouseReleased() {
  if (gamestate == 3){
    /* All the settings buttons */ 
    selfCollisionToggle.changeState(); 
    selfCollide = selfCollisionToggle.getState(); 
    teleportBordersToggle.changeState(); 
    teleportBorders = teleportBordersToggle.getState(); 
  }
}


  public void settings() { size(700, 700); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "SnakeGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
